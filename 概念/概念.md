# 概念
## 二叉树
- 后继节点: 中序遍历的顺序当中，一个节点的下一个节点就是它的后继节点。
- 前驱节点: 中序遍历的顺序当中，一个节点的前一个节点就是它的前驱节点。
- 平衡二叉树：每一个节点的左右高度差不超过一。
- 搜索二叉树：每一个节点比所有的左节点的值大，比所有的右节点的值小。
- 平衡搜索二叉树：即平衡，又是搜索二叉树。
## 时间复杂度
一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作，为 O(1)

先计算出一个表达式，然后不要底介项，只要高阶项，也不要高阶项的系数，用大 O 表示法

对于对数的计算: 一般是涉及到次方,例如 二分法不断缩小范围，每次缩小一半, 假设对于长度为 N 的数组需要缩减 O 次，且每次缩小一半，此时 2^O = N => O = log2(N), 所以时间复杂度为 O(log2(N))。需要注意如果平时没有写底数 2 ，那么默认就是以 2 为底数

分析一个算法: 先看上面的大 O 指标，如果指标一样，然后再去比较常数项。有时候需要根据具体的数据量，才能判断出这个算法的时间复杂度是多少
### 剖析递归行为和递归行为时间复杂度的估算
master 公式为 `T(N) = a*T(N/b) + O(N^d)`, 其中前半部分是调用子过程的数据量，后半部分是每个子过程当中的额外开销，a 是指在这个给定的样本量时，这个子过程发生了多少次，不用展开去管子过程中的子过程

分析递归过程的第一步, 计算出的时间复杂度如果满足上面的公式，那么可以使用下面的公式来求得最终的是时间复杂度

1. log(b,a) > d -> 复杂度为O(N^log(b,a))
2. log(b,a) = d -> 复杂度为O(N^d * logN)
3. log(b,a) < d -> 复杂度为O(N^d)

> 例子：经典快排
> 子过程分成两个当样本量问 N 时，子过程分为 a=2 部分，左右分别是 N/2 次，所以子过程时间复杂度为 2*T(N/2), 每一个子过程中，需要进行遍历，时间复杂度为 O(N), 所以加起来就为 2*T(N/2) + O(N), 根据上面的第二个公式，经典快排的时间复杂度就为 O(NlogN)